# encoding: UTF-8

module Calculator
  # Represents a node in the abstract syntax tree generated by Parser.
  #
  # The sublasses of this noee include:
  #
  # * ExpressionNode
  # * ExpressionPrimeNode
  # * TermNode
  # * TermPrimeNode
  # * FactorNode
  # * BaseNode
  #
  # Note that Token instances form the leaves of the tree.
  #
  class ASTNode
    # An array holding all of the children for this node, which may be empty.
    # Children will either be an ASTNode or a Token.
    attr_reader :children

    # Creates a new node with the given children
    def initialize(*children)
      @children = children
    end

    # Returns a semi-friendly string representation of the node
    def to_s
      node_type + '[' + @children.join(', ') + ']'
    end

    # Two nodes are equivalent if they have the same class and equivalent
    # children
    def ==(rhs)
      self.class == rhs.class && self.children == rhs.children
    end

    # Used to print a Graphviz directed graph to represent the parse tree
    def to_dot(counter = new_counter, parent = nil)
      id = "N#{counter.()}"
      out = "  #{id} [label=\"#{node_type}\"];\n"
      if parent
        out += "  #{parent} -> #{id};\n"
      end
      if children.empty?
        epsilon_id = "N#{counter.()}"
        out += "  #{epsilon_id} [label=\"ε\"];\n"
        out += "  #{id} -> #{epsilon_id};\n"
      else
        children.each do |child|
          if child.is_a? Calculator::Token
            token_id = "N#{counter.()}"
            out += "  #{token_id} [label=\"#{child.lexeme}\"];\n"
            out += "  #{id} -> #{token_id};\n"
          else
            out += child.to_dot(counter, id)
          end
        end
      end
      out
    end

    # Prints the tree headed by this node is a somewhat user-friendly format
    def print_tree(prefix = "")
      print "#{prefix}#{node_type}"
      if children.empty?
        puts ' = ε'
      else
        prefix += "  "
        puts
        children.each do |child|
          case child
            when Token
              puts "#{prefix}#{child.to_s}"
            when ASTNode
              child.print_tree(prefix)
          end
        end
      end
    end

    private

    # creates a new counter
    def new_counter
      count = 0
      lambda { count += 1 }
    end
  end

  # An <em>expression</em> in the grammar
  class ExpressionNode < ASTNode
    # Returns a name for the node type
    def node_type
      'expression'
    end
  end

  # An <em>expression′</em> in the grammar
  class ExpressionPrimeNode < ASTNode
    # Returns a name for the node type
    def node_type
      'expression′'
    end
  end

  # An <em>term</em> in the grammar
  class TermNode < ASTNode
    # Returns a name for the node type
    def node_type
      'term'
    end
  end

  # An <em>term′</em> in the grammar
  class TermPrimeNode < ASTNode
    # Returns a name for the node type
    def node_type
      'term′'
    end
  end

  # An <em>factor</em> in the grammar
  class FactorNode < ASTNode
    # Returns a name for the node type
    def node_type
      'factor'
    end
  end

  # An <em>base</em> in the grammar
  class BaseNode < ASTNode
    # Returns a name for the node type
    def node_type
      'base'
    end
  end
end
